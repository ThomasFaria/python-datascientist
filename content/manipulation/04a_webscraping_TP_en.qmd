---
title: "Web scraping avec Python"
draft: false
weight: 60
slug: webscraping
tags:
  - Webscraping
  - BeautifulSoup
  - Exercice
  - Manipulation
categories:
  - Exercice
  - Manipulation
type: book
description: |
  `Python` permet de facilement récupérer une page web pour en extraire des
  données à restructurer. Le _web scraping_, que les Canadiens nomment
  _"moissonnage du web"_, est une manière de plus en plus utilisée de
  récupérer une grande masse d'information en temps réel. 
  Ce chapitre présente les deux principaux paradigmes par le biais
  de `BeautifulSoup` et `Selenium` et les
  principaux défis du _web scraping_.
image: bulbasaur.jpg
echo: false
---

::: {.content-visible when-format="html"}
{{< include "../../build/_switch_lang.qmd" >}}

Pour essayer les exemples présents dans ce tutoriel : 

{{< include "../../build/_printBadges.qmd" >}}
:::


::: {.content-visible when-format="ipynb"}
{{warninglang}}
:::

[_Web scraping_](https://en.wikipedia.org/wiki/Web_scraping) refers to techniques for extracting content from websites. It is a very useful practice for anyone wanting to work with information available online that may not necessarily exist in an Excel table format.

This tutorial shows you how to create and run bots to quickly retrieve information useful for your current or future projects. It starts with a few concrete use cases. This chapter is heavily inspired and adapted from [Xavier Dupré's](http://www.xavierdupre.fr/app/ensae_teaching_cs/helpsphinx/notebooks/TD2A_Eco_Web_Scraping.html) chapter, the former professor of this course.

# Issues

A number of issues related to _web scraping_ will only be superficially discussed in this chapter.

## The legal grey area of _web scraping_

Firstly, regarding the legality of information retrieval through _scraping_, there is a gray area. Just because information is available on the internet, either directly or with some research, does not mean it can be retrieved and reused.

The excellent [course by Antoine Palazzolo](https://inseefrlab.github.io/formation-webscraping/) discusses several media and judicial cases on this question. In the French context, the CNIL published new guidelines in 2020 on *web scraping*, clarifying that no data can be reused without the knowledge of the person to whom these data belong. In other words, in principle, data collected by _web scraping_ are subject to the GDPR, meaning they require the consent of the individuals from whom the data is reused.

It is therefore recommended to __be cautious with the data retrieved__ by _web scraping_ to avoid legal issues.

## Stability and reliability of received information

While data retrieval through _web scraping_ is practical, it does not necessarily correspond to a usage envisioned or desired by a data provider. Data is expensive to collect and make available, and some sites may not want it to be extracted freely and easily. Especially when the data can provide a competitor with useful information from a commercial standpoint (e.g., competitor's product prices).

Therefore, actors often implement strategies to block or limit the amount of data scraped. The most common method is detecting and blocking requests made by robots rather than humans. For specialized actors, this detection is very easy as many indicators can identify whether a website visit comes from a human user behind a browser or a robot. A few examples of such indicators are: navigation speed between pages, speed of data extraction, the browser fingerprint used, ability to answer random questions (captcha), etc. The best practices discussed later aim to ensure that a robot behaves civilly by adopting behavior close to that of a human without pretending to be a human.

Moreover, caution should be exercised regarding information received through _web scraping_. Since data is at the heart of the economic model for some actors, some do not hesitate to send false data to robots rather than blocking them. It's fair game! Another trap technique is called the _honey pot_. These are pages that a human would never visit - for example, because they do not appear in the graphical interface - but on which a robot, in automatic content search, will get stuck.

Without going as far as the strategy of blocking _web scraping_, other reasons can explain why data retrieval may have worked in the past but no longer works. The most common is a change in the structure of a website. _Web scraping_ indeed has the disadvantage of fetching information from a highly hierarchical structure. A change in this structure can be enough to render a robot incapable of retrieving content. Moreover, to remain attractive, websites frequently change, which can easily make a robot inoperative.

In general, one of the main messages of this chapter to remember is that __web scraping is a last resort solution for occasional data retrievals without a guarantee of future operation__. It is preferable to __favor APIs when they are available__. These are more like a contract (formal or not) between a data provider and a user where needs (the data) as well as access conditions (number of requests, volume, authentication...) are defined, whereas _web scraping_ is closer to behavior in the _Far West_.

## Best practices

The ability to retrieve data through a robot does not mean one can afford to be uncivilized. Indeed, when uncontrolled, _web scraping_ can be like a classic cyber attack aimed at taking down a website: a denial of service attack. The [course by Antoine Palazzolo](https://inseefrlab.github.io/formation-webscraping/) reviews some good practices that have emerged in the scraping community. It is recommended to read this resource to learn more about this topic. Several conventions are mentioned, including:

- Go to the `robots.txt` file from the root of the site to check the instructions provided by the website developers to guide the behavior of robots;
- Space out each request by several seconds, as a human would, to avoid overloading the website and causing a denial of service;
- Make requests during off-peak hours if it is not an internationally visited website. For example, for a French site, running the robot during the night in mainland France is a good practice. To run a robot from `Python` at a pre-scheduled time, there are `cronjobs`.

# A detour to the web: how does a website work?

Even though this practical work does not aim to teach web development, you need some basics on how a website works to understand how information is structured on a page.

A website is a collection of pages coded in *HTML* that describe both the content and the form of a *Web* page.

To see this, open any web page and right-click on it.
- In `Chrome` <i class="fab fa-chrome"></i>: Then click on _"View page source"_ (<kbd>CTRL</kbd>+<kbd>U</kbd>);
- In `Firefox` <i class="fab fa-firefox"></i>: _"Page source"_ (<kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>K</kbd>);
- In `Edge` <i class="fab fa-edge"></i>: _"View page source"_ (<kbd>CTRL</kbd>+<kbd>U</kbd>);
- In `Safari` <i class="fab fa-safari"></i>: see how to do it [here](https://www.wikihow.com/View-Source-Code).

If you know which element interests you, you can also open the browser inspector (right-click on the element + "Inspect"), to display the tags surrounding your element more ergonomically, somewhat like a zoom.

## Tags

On a web page, you will always find elements such as `<head>`, `<title>`, etc. These are the codes that allow you to structure the content of an *HTML* page and are called **tags**. Examples of tags include `<p>`, `<h1>`, `<h2>`, `<h3>`, `<strong>`, and `<em>`.
The symbol ``< >`` is a tag: it indicates the beginning of a section. The symbol `</ >` indicates the end of this section. Most tags come in pairs, with an *opening tag* and a *closing tag* (for example, `<p>` and `</p>`).

For example, the main tags defining the structure of a table are as follows:

| Tag         | Description                        |
|-------------|------------------------------------|
| `<table>`   | Table                              |
| `<caption>` | Table title                        |
| `<tr>`      | Table row                          |
| `<th>`      | Header cell                        |
| `<td>`      | Cell                               |
| `<thead>`   | Table header section               |
| `<tbody>`   | Table body section                 |
| `<tfoot>`   | Table footer section               |


**Application: a table in HTML**

The `HTML` code for the following table:

```{html}
<table>
<caption> The title of my table </caption>

   <tr>
      <th>First name</th>
      <th>Last name</th>
      <th>Profession</th>
   </tr>
   <tr>
      <td>Mike</td>
      <td>Stuntman</td>
      <td>Stunt performer</td>
   </tr>
   <tr>
      <td>Mister</td>
      <td>Pink</td>
      <td>Gangster</td>
   </tr>
</table>
```

Will display in the browser as:

::: {.cell .markdown}
```{=html}
<table>
<caption> The title of my table </caption>

   <tr>
      <th>First name</th>
      <th>Last name</th>
      <th>Profession</th>
   </tr>
   <tr>
      <td>Mike</td>
      <td>Stuntman</td>
      <td>Stunt performer</td>
   </tr>
   <tr>
      <td>Mister</td>
      <td>Pink</td>
      <td>Gangster</td>
   </tr>
</table>
```
:::

## Les balises


Sur une page web, vous trouverez toujours à coup sûr des éléments comme `<head>`, `<title>`, etc. Il  s'agit des codes qui vous permettent de structurer le contenu d'une page *HTML* et qui s'appellent des **balises**. 
Citons, par exemple, les balises `<p>`, `<h1>`, `<h2>`, `<h3>`, `<strong>` ou `<em>`.
Le symbole ``< >`` est une balise : il sert à indiquer le début d'une partie. Le symbole `</ >` indique la fin de cette partie. La plupart des balises vont par paires, avec une *balise ouvrante* et une *balise fermante* (par exemple `<p>` et `</p>`).

Par exemple, les principales balises 
définissant la structure d'un tableau sont les suivantes :

| Balise      | Description                        |
|-------------|------------------------------------|
| `<table>`   | Tableau                            |
| `<caption>` | Titre du tableau                   |
| `<tr>`      | Ligne de tableau                   |
| `<th>`      | Cellule d'en-tête                  |
| `<td>`      | Cellule                            |
| `<thead>`   | Section de l'en-tête du tableau    |
| `<tbody>`   | Section du corps du tableau        |
| `<tfoot>`   | Section du pied du tableau         |


**Application : un tableau en HTML**

Le code `HTML` du tableau suivant :

```{html}
<table>
<caption> Le Titre de mon tableau </caption>

   <tr>
      <th>Prénom</th>
      <th>Nom</th>
      <th>Profession</th>
   </tr>
   <tr>
      <td>Mike </td>
      <td>Stuntman</td>
      <td>Cascadeur</td>
   </tr>
   <tr>
      <td>Mister</td>
      <td>Pink</td>
      <td>Gangster</td>
   </tr>
</table>
```

Donnera dans le navigateur :

::: {.cell .markdown}
```{=html}
<table>
<caption> Le Titre de mon tableau </caption>

   <tr>
      <th>Prénom</th>
      <th>Nom</th>
      <th>Profession</th>
   </tr>
   <tr>
      <td>Mike </td>
      <td>Stuntman</td>
      <td>Cascadeur</td>
   </tr>
   <tr>
      <td>Mister</td>
      <td>Pink</td>
      <td>Gangster</td>
   </tr>
</table>
```
:::

### Parent and child

In the context of HTML language, the terms parent and child refer to nested elements. For example, in the following construction:

```html
<div> 
    <p>
       bla, bla
    </p>
</div>
```

On the web page, this will appear as follows:

::: {.cell .markdown}
```{=html}
<div> 
    <p>
       bla,bla
    </p>
</div>
```
:::

We will say that the `<div>` element is the parent of the `<p>` element while the `<p>` element is the child of the `<div>` element.



> *But why learn this for "scraping"?*

Because to properly retrieve information from a website, you need to understand its structure and thus its HTML code. The `Python` functions used for scraping are primarily designed to allow you to navigate between tags. With `Python`, you will essentially reproduce your manual search behavior to automate it.

# Scraping with `Python`: the `BeautifulSoup` package

## Available packages

In the first part of this chapter, we will primarily use the [`BeautifulSoup4`](https://www.crummy.com/software/BeautifulSoup/bs4/doc/) package, in conjunction with [`urllib`](https://docs.python.org/3/library/urllib.html#module-urllib) or `requests`. These latter packages allow you to retrieve the raw text of a page, which will then be inspected via [`BeautifulSoup4`](https://www.crummy.com/software/BeautifulSoup/bs4/doc/).

`BeautifulSoup` will be enough when you want to work on static HTML pages. As soon as the information you are looking for is generated via the execution of [JavaScript](https://en.wikipedia.org/wiki/JavaScript) scripts, you will need to use tools like [Selenium](https://selenium-python.readthedocs.io/).

Similarly, if you do not know the URL, you will need to use a framework like [Scrapy](https://scrapy.org/), which easily moves from one page to another. This technique is called _"web crawling"_. `Scrapy` is more complex to handle than `BeautifulSoup`: if you want more details, go to the [Scrapy tutorial](https://doc.scrapy.org/en/latest/intro/tutorial.html).

Web scraping is a field where reproducibility is difficult to achieve. A web page may potentially change regularly, and from one web page to another, the structure can be very different, making some codes difficult to export. Therefore, the best way to have a functional program is to understand the structure of a web page and separate elements that can be exported to other use cases from ad hoc requests.

```{python}
#| echo: true
!pip install -q lxml

import bs4
import lxml
import pandas
import urllib

from urllib import request
```

::: {.note}
Pour être en mesure d'utiliser `Selenium`, il est nécessaire
de faire communiquer `Python` avec un navigateur _web_ (Firefox ou Chromium).
Le _package_ `webdriver-manager` permet de faire savoir à `Python` où
se trouve ce navigateur s'il est déjà installé dans un chemin standard.
Pour l'installer, le code de la cellule ci-dessous peut être utilisé.
:::

Pour faire fonctionner `Selenium`, il faut utiliser un package
nommé `webdriver-manager`: 

```{python}
#| echo: true
!pip install webdriver-manager
```

## Récupérer le contenu d'une page HTML

On va commencer doucement. Prenons une page _wikipedia_,
par exemple celle de la Ligue 1 de football, millésime 2019-2020 : [Championnat de France de football 2019-2020](https://fr.wikipedia.org/wiki/Championnat_de_France_de_football_2019-2020). On va souhaiter récupérer la liste des équipes, ainsi que les url des pages Wikipedia de ces équipes.

Etape 1️⃣ : se connecter à la page wikipedia et obtenir le code source.
Pour cela, le plus simple est d'utiliser le package `urllib` ou, mieux, `requests`.
Nous allons ici utiliser la fonction `request` du _package_ `urllib`:

```{python}
#| echo: true
url_ligue_1 = "https://fr.wikipedia.org/wiki/Championnat_de_France_de_football_2019-2020"
    
request_text = request.urlopen(url_ligue_1).read()
# print(request_text[:1000])    
```

```{python}
#| echo: true
type(request_text)
```

Etape 2️⃣ : utiliser le package BeautifulSoup
qui permet de rechercher efficacement
les balises contenues dans la chaine de caractères
renvoyée par la fonction `request`:


```{python}
#| echo: true
page = bs4.BeautifulSoup(request_text, "lxml")
```

Si on _print_ l'objet `page` créée avec `BeautifulSoup`,
on voit que ce n'est plus une chaine de caractères mais bien une page HTML avec des balises.
On peut à présent chercher des élements à l'intérieur de ces balises.

## La méthode `find`

Par exemple, si on veut connaître le titre de la page, on utilise la méthode `.find` et on lui demande *"title"*

```{python}
#| echo: true
print(page.find("title"))
```

La methode `.find` ne renvoie que la première occurence de l'élément. 

Pour vous en assurer vous pouvez :

- copier le bout de code source obtenu lorsque vous chercher une `table`, 
- le coller  dans une cellule de votre notebook
- et passer la cellule en _"Markdown"_


La cellule avec le copier-coller du code source donne : 

```{python}
#| echo: true
print(page.find("table"))
```

ce qui est le texte source permettant de générer le tableau suivant :

::: {.cell .markdown}
```{python}
#| echo: false
#| output: asis
print(page.find("table"))
```
:::

## La méthode `findAll`

Pour trouver toutes les occurences, on utilise `.findAll()`.

```{python}
#| echo: true
print("Il y a", len(page.findAll("table")), "éléments dans la page qui sont des <table>")
```


# Exercice guidé : obtenir la liste des équipes de Ligue 1

Dans le premier paragraphe de la page _"Participants"_,
on a le tableau avec les résultats de l'année. 

::: {.exercise}
## Exercice 1 : Récupérer les participants de la Ligue 1

Pour cela, nous allons procéder en 6 étapes:

1. Trouver le tableau
2. Récupérer chaque ligne du table
3. Nettoyer les sorties en ne gardant que le texte sur une ligne
4. Généraliser sur toutes les lignes
5. Récupérer les entêtes du tableau
6. Finalisation du tableau

:::

1️⃣ Trouver le tableau

```{python}
#| echo: true
# on identifie le tableau en question : c'est le premier qui a cette classe "wikitable sortable"
tableau_participants = page.find('table', {'class' : 'wikitable sortable'})
```

::: {.cell .markdown}
```{python}
#| echo: true
#| output: asis
print(tableau_participants)
```
:::

2️⃣ Récupérer chaque ligne du tableau

On recherche d'abord toutes les lignes du tableau avec la balise `tr`

```{python}
#| echo: true
table_body = tableau_participants.find('tbody')
rows = table_body.find_all('tr')
```

On obtient une liste où chaque élément est une des lignes du tableau
Pour illustrer cela, on va d'abord afficher la première ligne.
Celle-ci correspont aux entêtes de colonne:

```{python}
#| echo: true
print(rows[0])
```


La seconde ligne va correspondre à la ligne du premier club présent dans le tableau :

```{python}
#| echo: true
print(rows[1])
```



3️⃣ Nettoyer les sorties en ne gardant que le texte sur une ligne


On va utiliser l'attribut `text` afin de se débarasser de toute la couche de HTML qu'on obtient à l'étape 2.

Un exemple sur la ligne du premier club :
- on commence par prendre toutes les cellules de cette ligne, avec la balise `td`.
- on fait ensuite une boucle sur chacune des cellules et on ne garde que le texte de la cellule avec l'attribut `text`.
- enfin, on applique la méthode `strip()` pour que le texte soit bien mis en forme (sans espace inutile etc).


```{python}
#| echo: true
cols = rows[1].find_all('td')
print(cols[0])
print(cols[0].text.strip())
```

```{python}
#| echo: true
for ele in cols : 
    print(ele.text.strip())
```

4️⃣ Généraliser sur toutes les lignes :

```{python}
#| echo: true
for row in rows:
    cols = row.find_all('td')
    cols = [ele.text.strip() for ele in cols]
    print(cols)
```

On a bien réussi à avoir les informations contenues dans le tableau des participants du championnat.
Mais la première ligne est étrange : c'est une liste vide ... 

Il s'agit des en-têtes : elles sont reconnues par la balise `th` et non `td`. 

On va mettre tout le contenu dans un dictionnaire, pour le transformer ensuite en DataFrame pandas : 

```{python}
#| code-overflow: wrap
#| echo: true

dico_participants = dict()
for row in rows:
    cols = row.find_all('td')
    cols = [ele.text.strip() for ele in cols]
    if len(cols) > 0 : 
        dico_participants[cols[0]] = cols[1:]
dico_participants
```

```{python}
#| echo: true
data_participants = pandas.DataFrame.from_dict(dico_participants,orient='index')
data_participants.head()
```


5️⃣ Récupérer les en-têtes du tableau :

```{python}
#| echo: true
for row in rows:
    cols = row.find_all('th')
    print(cols)
    if len(cols) > 0 : 
        cols = [ele.get_text(separator=' ').strip().title() for ele in cols]
        columns_participants = cols
```

```{python}
#| echo: true
columns_participants
```

6️⃣ Finalisation du tableau 

```{python}
#| echo: true
data_participants.columns = columns_participants[1:]
```

```{python}
#| echo: true
data_participants.head()
```


# Pour aller plus loin

## Récupération des localisations des stades

Essayez de comprendre pas à pas ce qui est fait dans les étapes qui suivent (la récupération d'informations supplémentaires en naviguant dans les pages des différents clubs). 

```{python}
#| echo: true
#| output: false

import urllib
import pandas as pd
import bs4 

division=[]
equipe=[]
stade=[]
latitude_stade=[]        
longitude_stade=[]     

url_list=["http://fr.wikipedia.org/wiki/Championnat_de_France_de_football_2019-2020", "http://fr.wikipedia.org/wiki/Championnat_de_France_de_football_de_Ligue_2_2019-2020"]

for url_ligue in url_list :
       
    print(url_ligue)
    sock = urllib.request.urlopen(url_ligue).read() 
    page=bs4.BeautifulSoup(sock)

# Rechercher les liens des équipes dans la liste disponible sur wikipedia 

    for team in page.findAll('span' , {'class' : 'toponyme'}) :  
        
        # Indiquer si c'est de la ligue 1 ou de la ligue 2
        
        if url_ligue==url_list[0] :
            division.append("L1")
        else :
            division.append("L2")

       # Trouver le nom et le lien de l'équipe
            
        if team.find('a')!=None :
            team_url=team.find('a').get('href')
            name_team=team.find('a').get('title')
            equipe.append(name_team)
            url_get_info = "http://fr.wikipedia.org"+team_url
            print(url_get_info)
 
       # aller sur la page de l'équipe
           
            search = urllib.request.urlopen(url_get_info).read()
            search_team=bs4.BeautifulSoup(search)

       # trouver le stade             
            compteur = 0
            for stadium in search_team.findAll('tr'):
                for x in stadium.findAll('th' , {'scope' : 'row'} ) :
                    if x.contents[0].string=="Stade" and compteur == 0:
                        compteur = 1
                        # trouver le lien du stade et son nom
                        url_stade=stadium.findAll('a')[1].get('href')
                        name_stadium=stadium.findAll('a')[1].get('title')
                        stade.append(name_stadium)
                        url_get_stade = "http://fr.wikipedia.org"+url_stade
                        print(url_get_stade)
                        
                        # Aller sur la page du stade et trouver ses coodronnées géographiques
                        
                        search_stade = urllib.request.urlopen(url_get_stade).read()
                        soup_stade=bs4.BeautifulSoup(search_stade) 
                        kartographer = soup_stade.find('a',{'class': "mw-kartographer-maplink"})
                        if kartographer == None :
                          latitude_stade.append(None)
                          longitude_stade.append(None) 
                        else :
                            for coordinates in kartographer :
                                print(coordinates)
                                liste =   coordinates.split(",")          
                                latitude_stade.append(str(liste[0]).replace(" ", "") + "'")
                                longitude_stade.append(str(liste[1]).replace(" ", "") + "'")
                            

dict = {'division' : division , 'equipe': equipe, 'stade': stade, 'latitude': latitude_stade, 'longitude' : longitude_stade}
data = pd.DataFrame(dict)
data = data.dropna()
```

```{python}
#| echo: true
data.head(5)
```

On va transformer les coordonnées en degrés en coordonnées numériques
afin d'être en mesure de faire une carte.

```{python}
#| echo: true
import re

def dms2dd(degrees, minutes, seconds, direction):
    dd = float(degrees) + float(minutes)/60 + float(seconds)/(60*60);
    if direction in ('S', 'O'):
        dd *= -1
    return dd

def parse_dms(dms):
    parts = re.split('[^\d\w]+', dms)
    lat = dms2dd(parts[0], parts[1], parts[2], parts[3])
    #lng = dms2dd(parts[4], parts[5], parts[6], parts[7])
    return lat
```

```{python}
#| echo: true
data['latitude'] = data['latitude'].apply(parse_dms)
data['longitude'] = data['longitude'].apply(parse_dms)
```

Tous les éléments sont en place pour faire une belle carte à ce stade. On
va utiliser `folium` pour celle-ci, qui est présenté dans la partie
[visualisation](#cartotp).

## Carte des stades avec `folium` {#cartes-stades-ligue1}

```{python}
#| echo: true
#| output: false

import geopandas as gpd
from pathlib import Path
import folium

gdf = gpd.GeoDataFrame(
    data, geometry=gpd.points_from_xy(data.longitude, data.latitude))

Path("leaflet").mkdir(parents=True, exist_ok=True)

center = gdf[['latitude', 'longitude']].mean().values.tolist()
sw = gdf[['latitude', 'longitude']].min().values.tolist()
ne = gdf[['latitude', 'longitude']].max().values.tolist()

m = folium.Map(location = center, tiles='openstreetmap')

# I can add marker one by one on the map
for i in range(0,len(gdf)):
    folium.Marker([gdf.iloc[i]['latitude'], gdf.iloc[i]['longitude']], popup=gdf.iloc[i]['stade']).add_to(m) 

m.fit_bounds([sw, ne])
```

La carte obtenue doit ressembler à la suivante :

```{python}
# Afficher la carte
m
```


# Récupérer des informations sur les pokemons

Le prochain exercice pour mettre en pratique le _web scraping_
consiste à récupérer des informations sur les 
pokemons à partir du 
site internet [pokemondb.net](http://pokemondb.net/pokedex/national). 

## Version non guidée


::: {.exercise} 
## Exercice 2 : Les pokemon (version non guidée)

Pour cet exercice, nous vous demandons d'obtenir différentes informations sur les pokémons :

1. les informations personnelles des __893__ pokemons sur le site internet [pokemondb.net](http://pokemondb.net/pokedex/national).
Les informations que nous aimerions obtenir au final dans un `DataFrame` sont celles contenues dans 4 tableaux :

- Pokédex data
- Training
- Breeding
- Base stats

2. Nous aimerions que vous récupériez également les images de chacun des pokémons et que vous les enregistriez dans un dossier  

* Petit indice : utilisez les modules `request` et [`shutil`](https://docs.python.org/3/library/shutil.html)
* Pour cette question, il faut que vous cherchiez de vous même certains éléments, tout n'est pas présent dans le TD.

:::

Pour la question 1, l'objectif est d'obtenir le code source d'un tableau comme
celui qui suit
(Pokemon [Nincada](http://pokemondb.net/pokedex/nincada)).

::: {.cell .markdown}
<div class="grid-col span-md-6 span-lg-4">
<h2>Pokédex data</h2>
<table class="vitals-table">
<tbody>
<tr>
<th>National №</th>
<td><strong>290</strong></td>
</tr>
<tr>
<th>Type</th>
<td>
<a class="type-icon type-bug" href="/type/bug">Bug</a> <a class="type-icon type-ground" href="/type/ground">Ground</a> </td>
</tr>
<tr>
<th>Species</th>
<td>Trainee Pokémon</td>
</tr>
<tr>
<th>Height</th>
<td>0.5&nbsp;m (1′08″)</td>
</tr>
<tr>
<th>Weight</th>
<td>5.5&nbsp;kg (12.1&nbsp;lbs)</td>
</tr>
<tr>
<th>Abilities</th>
<td><span class="text-muted">1. <a href="/ability/compound-eyes" title="The Pokémon's accuracy is boosted.">Compound Eyes</a></span><br><small class="text-muted"><a href="/ability/run-away" title="Enables a sure getaway from wild Pokémon.">Run Away</a> (hidden ability)</small><br></td>
</tr>
<tr>
<th>Local №</th>
<td>042 <small class="text-muted">(Ruby/Sapphire/Emerald)</small><br>111 <small class="text-muted">(X/Y — Central Kalos)</small><br>043 <small class="text-muted">(Omega Ruby/Alpha Sapphire)</small><br>104 <small class="text-muted">(Sword/Shield)</small><br></td>
</tr>
</tbody>
</table>
</div>


<div class="grid-col span-md-12 span-lg-4">
<div class="grid-row">
<div class="grid-col span-md-6 span-lg-12">
<h2>Training</h2>
<table class="vitals-table">
<tbody>
<tr>
<th>EV yield</th>
<td class="text">
1 Defense </td>
</tr>
<tr>
<th>Catch rate</th>
<td>255 <small class="text-muted">(33.3% with PokéBall, full HP)</small></td>
</tr>
<tr>
<th>Base <a href="/glossary#def-friendship">Friendship</a></th>
<td>70 <small class="text-muted">(normal)</small></td>
</tr>
<tr>
<th>Base Exp.</th>
<td>53</td>
</tr>
<tr>
<th>Growth Rate</th>
<td>Erratic</td>
</tr>
</tbody>
</table>
</div>
<div class="grid-col span-md-6 span-lg-12">
<h2>Breeding</h2>
<table class="vitals-table">
<tbody>
<tr>
<th>Egg Groups</th>
<td>
<a href="/egg-group/bug">Bug</a> </td>
</tr>
<tr>
<th>Gender</th>
<td><span class="text-blue">50% male</span>, <span class="text-pink">50% female</span></td> </tr>
<tr>
<th><a href="/glossary#def-eggcycle">Egg cycles</a></th>
<td>15 <small class="text-muted">(3,599–3,855 steps)</small>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div class="grid-col span-md-12 span-lg-8">
<div id="dex-stats"></div>
<h2>Base stats</h2>
<div class="resp-scroll">
<table class="vitals-table">
<tbody>
<tr>
<th>HP</th>
<td class="cell-num">31</td>
<td class="cell-barchart">
<div style="width:17.22%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">172</td>
<td class="cell-num">266</td>
</tr>
<tr>
<th>Attack</th>
<td class="cell-num">45</td>
<td class="cell-barchart">
<div style="width:25.00%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">85</td>
<td class="cell-num">207</td>
</tr>
<tr>
<th>Defense</th>
<td class="cell-num">90</td>
<td class="cell-barchart">
<div style="width:50.00%;" class="barchart-bar barchart-rank-4 "></div>
</td>
<td class="cell-num">166</td>
<td class="cell-num">306</td>
</tr>
<tr>
<th>Sp. Atk</th>
<td class="cell-num">30</td>
<td class="cell-barchart">
<div style="width:16.67%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">58</td>
<td class="cell-num">174</td>
</tr>
<tr>
<th>Sp. Def</th>
<td class="cell-num">30</td>
<td class="cell-barchart">
<div style="width:16.67%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">58</td>
<td class="cell-num">174</td>
</tr>
<tr>
<th>Speed</th>
<td class="cell-num">40</td>
<td class="cell-barchart">
<div style="width:22.22%;" class="barchart-bar barchart-rank-2 "></div>
</td>
<td class="cell-num">76</td>
<td class="cell-num">196</td>
</tr>
</tbody>
<tfoot>
<tr>
<th>Total</th>
<td class="cell-total"><b>266</b></td>
<th class="cell-barchart"></th>
<th>Min</th>
<th>Max</th>
</tr>
</tfoot>
</table>
</div>
</div>
:::

Pour la question 2, l'objectif est d'obtenir
les images des pokemon. 


## Version guidée

Les prochaines parties permettront de faire l'exercice ci-dessus
étape par étape, 
de manière guidée.

Nous souhaitons tout d'abord obtenir les
informations personnelles de tous
les pokemons sur [pokemondb.net](http://pokemondb.net/pokedex/national).

Les informations que nous aimerions obtenir au final pour les pokemons sont celles contenues dans 4 tableaux :

- Pokédex data
- Training
- Breeding
- Base stats

Nous proposons ensuite de récupérer et afficher les images.

### Etape 1: constituer un DataFrame de caractéristiques

::: {.exercise}
## Exercice 2b : Les pokémons (version guidée)

Pour récupérer les informations, le code devra être divisé en plusieurs étapes : 


1. Trouvez la page principale du site et la transformer en un objet intelligible pour votre code.
Les fonctions suivantes vous seront utiles :
- `urllib.request.Request`
- `urllib.request.urlopen`
- `bs4.BeautifulSoup`

2. Créez une fonction qui permet de récupérer la page d'un pokémon à partir de son nom.

3. A partir de la page de `bulbasaur`, obtenez les 4 tableaux qui nous intéressent :
- on va chercher l'élément suivant : `('table', { 'class' : "vitals-table"})`
- puis stocker ses éléments dans un dictionnaire

4. Récupérez par ailleurs la liste de noms des pokémons qui nous permettra de faire une boucle par la suite. Combien trouvez-vous de pokémons ? 

5. Ecrire une fonction qui récupère l'ensemble des informations sur les dix premiers pokémons de la liste et les intègre dans un `DataFrame`

:::



```{python}
#| output: false

# 1. trouver la page principale du site et la transformer en un objet intelligible pour votre code.
import urllib
import bs4
import collections
import pandas as pd

# pour le site que nous utilisons, le user agent de Python 3 n'est pas bien passé :
# on le change donc pour celui de Mozilla

req = urllib.request.Request('http://pokemondb.net/pokedex/national',
                             headers={'User-Agent': 'Mozilla/5.0'})
html = urllib.request.urlopen(req).read()
page = bs4.BeautifulSoup(html, "lxml")
#page.findAll('span', {'class': 'infocard-lg-img'})
```


```{python}
#| output: false

# 2. Créez une fonction qui permet de récupérer la page d'un pokémon à partir de son nom
#https://pokemondb.net/pokedex/bulbasaur

def get_page(pokemon_name):
    url_pokemon = 'http://pokemondb.net/pokedex/'+ pokemon_name
    req = urllib.request.Request(url_pokemon, headers = {'User-Agent' : 'Mozilla/5.0'})
    html = urllib.request.urlopen(req).read()
    return bs4.BeautifulSoup(html, "lxml")

#get_page("bulbasaur")
```

```{python}
#| output: false

# 3. A partir de la page de Bulbasaur, obtenir les 4 tableaux qui nous intéressent et les stocker dans un dictionnaire
#https://pokemondb.net/pokedex/bulbasaur

# On explore un peu
page_pokemon = get_page("bulbasaur")

indice_tableau = 0 #premier tableau : 0
print("\n tableau", indice_tableau+1, " : deux premières lignes")
tableau_1 = page_pokemon.findAll('table', { 'class' : "vitals-table"})[indice_tableau] 
for elements in tableau_1.find('tbody').findChildren(['tr'])[0:2]:  #Afficher les 2 éléments du tableau
    print(elements.findChild('th'))
    print(elements.findChild('td'))
print("\n\n\n")

# On automatise : fonction pour stocker dans un dictionnaire
def get_cara_pokemon(pokemon_name):
    page = get_page(pokemon_name)
    data = {}
    for table in page.findAll('table', { 'class' : "vitals-table"})[0:4] :
        table_body = table.find('tbody')
        for rows in table_body.findChildren(['tr']) :
            if len(rows) > 1 : # attention aux tr qui ne contiennent rien
                column = rows.findChild('th').getText()
                cells = rows.findChild('td').getText()
                cells = cells.replace('\t','').replace('\n',' ')
                data[column] = cells
                data['name'] = pokemon_name
    return data
```

A l'issue de la question 3,
vous devriez obtenir une liste de caractéristiques proche de celle-ci :

```{python}
get_cara_pokemon("bulbasaur")
```

La structure est ici en dictionnaire, ce qui est pratique. 

```{python}
#| output: false

# 4. Récupérez la liste de noms des pokémons
liste_pokemon =[]
for pokemon in page.findAll('span', {'class': 'infocard-lg-img'}) :
    pokemon = pokemon.find('a').get('href').replace("/pokedex/",'')
    liste_pokemon.append(pokemon)
print(len(liste_pokemon)) #898
liste_pokemon[0:10]
```

Enfin, vous pouvez intégrer les informations 
des dix premiers pokémons à un
`DataFrame`, qui aura l'aspect suivant :

```{python}
#| output: false

# 5. Informations sur les dix premiers pokémons de la liste intégrées dans un data.frame
items = []
for pokemon in liste_pokemon[0:10] :
    item = get_cara_pokemon(pokemon)
    items.append(item)
df = pd.DataFrame(items)
```

```{python}
#| echo: false
df.head()
```


### Etape 2: récupérer et afficher des photos de Pokemon

Nous aimerions que vous récupériez également les images des 5 premiers pokémons
et que vous les enregistriez dans un dossier.

::: {.exercise}
## Exercice 2b : Les pokémons (version guidée)

- Les URL des images des pokemon prennent la forme _"https://img.pokemondb.net/artwork/{pokemon}.jpg"_. 
Utiliser les modules `requests` et `shutil` pour télécharger 
et enregistrer en local les images. 
- Importer ces images stockées au format JPEG dans `Python` grâce à la fonction `imread` du package `skimage.io`

:::

```{python}
#| echo: true
!pip install scikit-image
```


```{python}
#| include: false
#| echo: false

# Correction de l'étape 2
import shutil
import requests
import os
import matplotlib.pyplot as plt
import skimage.io as imio

nb_pokemons = 5
fig, ax = plt.subplots(1, nb_pokemons, figsize=(12,4))
for indice_pokemon in range(0,nb_pokemons) :
    pokemon = liste_pokemon[indice_pokemon]
    url = f"https://img.pokemondb.net/artwork/{pokemon}.jpg"
    response = requests.get(url, stream=True)
    with open(f'{pokemon}.jpg', 'wb') as out_file:
        shutil.copyfileobj(response.raw, out_file)
    name = f'{pokemon}.jpg'
    img = imio.imread(name)
    ax[indice_pokemon].imshow(img)  
    ax[indice_pokemon].get_xaxis().set_visible(False)
    ax[indice_pokemon].get_yaxis().set_visible(False)
```

```{python}
#| echo: false
#plt.savefig('pokemon.png', bbox_inches='tight')
ax[0].get_figure()
```



# `Selenium` : mimer le comportement d'un utilisateur internet


Jusqu'à présent,
nous avons raisonné comme si nous connaissions toujours l'url qui nous intéresse.
De plus, les pages que nous visitons sont __"statiques"__,
elles ne dépendent pas d'une action ou d'une recherche de l'internaute. 

Nous allons voir à présent comment nous en sortir pour remplir
des champs sur un site _web_ et récupérer ce qui nous intéresse. 
La réaction d'un site _web_ à l'action d'un utilisateur passe régulièrement par
l'usage de `JavaScript` dans le monde du développement _web_. 
Le _package_ [Selenium](https://pypi.python.org/pypi/selenium) permet 
de reproduire, depuis un code automatisé, le comportement
manuel d'un utilisateur. Il permet ainsi
d'obtenir des informations du site qui ne sont pas dans le
code `HTML` mais qui apparaissent uniquement à la suite de
l'exécution de script `JavaScript` en arrière plan. 

`Selenium` se comporte comme un utilisateur _lambda_ sur internet :
il clique sur des liens, il remplit des formulaires, etc.

## Premier exemple en scrapant un moteur de recherche

Dans cet exemple, nous allons essayer d'aller sur le
site de [Bing Actualités](https://www.bing.com/news)
et entrer dans la barre de recherche un sujet donné.
Pour tester, nous allons faire une recherche avec le mot-clé __"Trump"__. 

L'installation de `Selenium` nécessite d'avoir `Chromium` qui est un 
navigateur Google Chrome minimaliste. 
La version de [chromedriver](https://sites.google.com/a/chromium.org/chromedriver/)
doit être `>= 2.36` et dépend de la version de `Chrome` que vous avez sur votre environnement
de travail. Pour installer cette version minimaliste de `Chrome` sur un environnement
`Linux`, vous pouvez vous référer à l'encadré dédié.


::: {.important}
## Installation de `Selenium`

D'abord, il convient d'installer les dépendances. 
Sur `Colab`, vous pouvez utiliser les commandes suivantes :

```{python}
#| eval: false
#| echo: true
!sudo apt-get update
!sudo apt install -y unzip xvfb libxi6 libgconf-2-4 -y
!sudo apt install chromium-chromedriver -y
!cp /usr/lib/chromium-browser/chromedriver /usr/bin
```

<br>

Si vous êtes sur le `SSP Cloud`, vous pouvez
exécuter les commandes suivantes :

```{python}
#| echo: true
#| output: false
!wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb -O /tmp/chrome.deb
!sudo apt-get update
!sudo -E apt-get install -y /tmp/chrome.deb
!pip install chromedriver-autoinstaller selenium

import chromedriver_autoinstaller
chromedriver_autoinstaller.install()
```

<br>

Vous pouvez ensuite installer `Selenium`.
Par exemple, depuis une
cellule de `Notebook` :

```{python}
#| output: false
!pip install selenium
```

:::

Après avoir installé `Chromium`, 
il est nécessaire d'indiquer à `Python` où
le trouver. Si vous êtes sur `Linux` et que vous
avez suivi les consignes précédentes, vous pouvez faire :

```{python}
#| output: false
#| echo: true
import selenium
from webdriver_manager.chrome import ChromeDriverManager

path_to_web_driver = ChromeDriverManager().install()
```

En premier lieu, il convient d'initialiser le comportement
de `Selenium` en répliquant les paramètres
du navigateur. Pour cela, on va d'abord initialiser
notre navigateur avec quelques options :

```{python}
#| output: false
#| echo: true
import time

from selenium import webdriver
from selenium.webdriver.common.keys import Keys

chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument('--headless')
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disable-dev-shm-usage')
#chrome_options.add_argument('--verbose') 
```

Puis on lance le navigateur :

```{python}
#| echo: true
#| output: false
from selenium.webdriver.chrome.service import Service
service = Service(executable_path=path_to_web_driver)

browser = webdriver.Chrome(service=service,
                           options=chrome_options)
```

On va sur le site de `Bing Actualités`,
et on lui indique le mot clé que nous souhaitons chercher. 
En l'occurrence, on s'intéresse aux actualités de Donald Trump.
Après avoir inspecté la page depuis les outils de développement du navigateur,
on voit que la barre de recherche est un élement du code appelé `q` (comme _query_).
On va ainsi demander à `selenium` de chercher cet élément:

```{python}
#| echo: true
#| output: false
browser.get('https://www.bing.com/news')

search = browser.find_element("name", "q")
print(search)
print([search.text, search.tag_name, search.id])

# on envoie à cet endroit le mot qu'on aurait tapé dans la barre de recherche
search.send_keys("Trump")

search_button = browser.find_element("xpath", "//input[@id='sb_form_go']") 
search_button.click()
```

`Selenium` permet de capturer l'image qu'on verrait dans le navigateur
avec `get_screenshot_as_png`. Cela peut être utile pour vérifier qu'on
a fait la bonne action :

```{python}
#| output: false
png = browser.get_screenshot_as_png()
```

```{python}
from IPython.display import Image
Image(png, width='500')
```

Enfin, on peut extraire les résultats. Plusieurs
méthodes sont disponibles. La méthode la plus
pratique, lorsqu'elle est disponible,
est d'utiliser le `XPath` qui est un chemin
non ambigu pour accéder à un élement. En effet,
plusieurs éléments peuvent partager la même classe ou 
le même attribut ce qui peut faire qu'une recherche 
de ce type peut renvoyer plusieurs échos. 
Pour déterminer le `XPath` d'un objet, les outils
de développeurs de votre site _web_ sont pratiques. 
Par exemple, sous `Firefox`, une fois que vous
avez trouvé un élément dans l'inspecteur, vous
pouvez faire `click droit > Copier > XPath`. 

```{python}
from selenium.common.exceptions import StaleElementReferenceException
links = browser.find_elements("xpath", "//div/a[@class='title'][@href]")

results = []
for link in links:
    try:
        url = link.get_attribute('href')
    except StaleElementReferenceException as e:
        print("Issue with '{0}' and '{1}'".format(url, link))
        print("It might be due to slow javascript which produces the HTML page.")
    results.append(url)
```

Enfin, pour mettre fin à notre session, on demande
à `Python` de quitter le navigateur:

```{python}
#| echo: true
#| output: false
browser.quit()
```

On a obtenu les résultats suivants :


```{python}
#| code-overflow: wrap
print(results)
```

Les autres méthodes utiles de `Selenium`:

| Méthode | Résultat |
|-------------------------------|--------------|
| `find_element(****).click()` | Une fois qu'on a trouvé un élément réactif, notamment un bouton, on peut cliquer dessus pour activer une nouvelle page |
| `find_element(****).send_keys("toto")` | Une fois qu'on a trouvé un élément, notamment un champ où s'authentifier, on peut envoyer une valeur, ici _"toto"_. 


## Utiliser `Selenium` pour jouer à 2048

Dans cet exemple, on utilise le module pour que `Python`
appuie lui même sur les touches du clavier afin de jouer à 2048.

Note : ce bout de code ne donne pas une solution à 2048,
il permet juste de voir ce qu'on peut faire avec `Selenium`.

```{python}
#| eval: false
#| echo: true

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.keys import Keys

# on ouvre la page internet du jeu 2048
service = Service(executable_path=path_to_web_driver)

browser = webdriver.Chrome(service=service,
                           options=chrome_options)
browser.get('https://play2048.co//')

# Ce qu'on va faire : une boucle qui répète inlassablement la même chose : haut / droite / bas / gauche

# on commence par cliquer sur la page pour que les touches sachent 
button = browser.find_element("class name", 'grid-container')
browser.execute_script("arguments[0].click();", button)
time.sleep(0.5)

grid = browser.find_element("tag name", 'body')

# pour savoir quels coups faire à quel moment, on crée un dictionnaire
direction = {0: Keys.UP, 1: Keys.RIGHT, 2: Keys.DOWN, 3: Keys.LEFT}
count = 0

while True:
    try: # on vérifie que le bouton "Try again" n'est pas là - sinon ça veut dire que le jeu est fini
        retryButton = browser.find_element("link text",'Try again')
        scoreElem = browser.find_element("class name", 'score-container')
        break
    except:
        #Do nothing.  Game is not over yet
        pass
    # on continue le jeu - on appuie sur la touche suivante pour le coup d'après
    count += 1
    grid.send_keys(direction[count % 4]) 
    time.sleep(0.1)

print('Score final : {} en {} coups'.format(scoreElem.text, count))    
browser.quit()
```

## Exercice supplémentaire

Pour découvrir une autre application possible du _web scraping_, vous pouvez également vous lancer dans le sujet 5 de l'édition 2023 d'un hackathon non compétitif organisé par l'Insee :

- Sur [`Github`](https://github.com/InseeFrLab/funathon2023_sujet5)
- Sur le [`SSPCloud`](https://www.sspcloud.fr/formation?search=funat&path=%5B%22Funathon%202023%22%5D)

Le contenu de la section NLP du cours pourra vous être utile pour la seconde partie du sujet !
